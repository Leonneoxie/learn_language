P.50 で「再帰呼び出しを使っているプログラムは、再帰呼び出しを使わなくても書くことができる。」と説明しました。
これは脚注にも書いたとおり「興味のある人は実装してみましょう」というスタンスでしたが、補足記事としてここで解説することにしました。

P.53の簡単な再帰呼び出しの例(total関数)をターゲットにします。
これは空行とコメントを除くと8行の簡単な例です。
このコードから、挙動を変えずに再帰呼び出しを取り除いてみましょう。
腕に自身のある人はは続きを読む前に自分で実装してみるとよいでしょう。

** foreachの除去

まず、このコードでは「for x in xs」というforeach構文があります。
これは「与えられたリストの各要素についてループする」という構文なので、中断したり再開したりすることが難しいです。
そこで、まずはこれをwhile文に書き換えましょう。

>|python|
def total2(xs):
    # 初期化
    result = 0
    i = 0

    # for文に相当
    while i < len(xs):
        x = xs[i]
        i += 1
        if is_integer(x):
            result += x
        else:
            result += total(x)

    return result
||<

** スタックを作る

普通の関数呼び出しでは言語処理系が面倒を見てくれる「スタック」ですが、
今回は関数呼び出しを使わずに関数呼び出しと同じことを実現したいわけなので、
自分で管理することにします。

とはいえ、それほど大げさなことではありません。空のリストを作ってstackという名前で呼ぶことにします。
Pythonではstack.append(x)でxを末尾に追加できます。
また、stack.pop()でxの末尾の要素を取り除き、返り値として得ることができます。

>|python|
    stack = []
    stack.append(x)
    x = stack.pop()
||<

** スタックに保管するべきこの関数のローカル関数は何か

先ほどのstackという変数は、この関数のローカル変数です。
でも、今回作ろうとしている「擬似的な関数呼び出し」の為の変数ですから、保管の対象ではありませんね。

関数を呼び出して戻ってきた時に「何を復元する必要があるか？」を考えるといいでしょう。

復元する必要があるのは、result, xs, i の3つです。この3つを保管すればよいでしょう。

xも保管しようとした？それでもOKです。細かいことを考えずにxも保管してしまってもよいでしょう。
ただ、xは関数呼び出しから戻った後で読み出されることがないので今回は省きました。


** 「関数の呼び出し」とは何か

さて、次は「関数の呼び出し」とは何をすることか考えてみましょう。

- 今の状態をスタックに保管して、後で戻せるようにする
- 引数xsを書き換える
- 関数冒頭にジャンプ

>|python|
def total3(xs):
    stack = []
    # 初期化
    result = 0
    i = 0

    # 再帰呼び出しでの「関数冒頭へのジャンプ」に相当
    while True:

        # for文に相当
        while i < len(xs):
            x = xs[i]
            i += 1
            if is_integer(x):
                result += x
            else:
                ## 関数の呼び出しに相当
                # 今の状態をスタックに積む
                stack.append((xs, i, result))
                # xsを変える(xを引数としてtotalを呼ぶことに相当)
                xs = x
                # 初期化
                result = 0
                i = 0
                break

        if i == len(xs):
            # ループが完了した
            if stack: # スタックが空でないなら
                # 積んでおいた値を取り出す
                old_xs, old_i, old_result = stack.pop()
                # 値を元に戻す
                xs = old_xs
                i = old_i
                result = old_result + result # result += total(x)で返り値を足していることに相当
            else:
                break

    return result
||<
